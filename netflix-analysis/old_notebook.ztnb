notebookId = "b74efe6b-2e43-4ee2-b1cc-fd0869bee516"
notebookName = "Zero True"

[cells.7ad76741-b0e8-417f-9106-edca7712b2d1]
cellName = ""
cellType = "markdown"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
# Netflix Movies and TV Shows
Listings of movies and tv shows on Netflix - Regularly Updated.

This tabular dataset consists of listings of all the movies and tv shows available on Netflix, along with details such as:
* show_id: Unique ID for every Movie / Tv Show
* type: Identifier - A Movie or TV Show
* title: Title of the Movie / Tv Show
* director: Director of the Movie
* cast: Actors involved in the movie / show
* country: Country where the movie / show was produced
* date_added: Date it was added on Netflix
* release_year: Actual Release year of the move / show
* rating: TV Rating of the movie / show
* duration: Total Duration - in minutes or number of seasons"""

[cells.994d1c6e-0797-40e8-a3bf-0d8442a1b2d2]
cellName = "Kaggle Dataset Download"
cellType = "code"
hideCell = "False"
hideCode = "True"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
import os
import json
with open(r'kaggle.json') as f:
    kaggle_credentials = json.load(f)
os.environ['KAGGLE_USERNAME'] = kaggle_credentials['username']
os.environ['KAGGLE_KEY'] = kaggle_credentials['key']

from kaggle.api.kaggle_api_extended import KaggleApi

def download_kaggle_dataset(dataset, download_path):
    # Initialize Kaggle API
    api = KaggleApi()
    api.authenticate()

    if not os.path.exists(download_path):
        os.makedirs(download_path)

    api.dataset_download_files(dataset, path=download_path, unzip=True)

kaggle_dataset = 'shivamb/netflix-shows'  # Replace with the actual dataset path on Kaggle
download_folder = './netflix-shows'  # Replace with your desired download folder path

download_kaggle_dataset(kaggle_dataset, download_folder)
print(f"Dataset downloaded and extracted to {download_folder}")
"""

[cells.5fff8cd0-27cd-4342-a9ac-b44666ec8474]
cellName = "Kaggle Dataset Location"
cellType = "code"
hideCell = "False"
hideCode = "True"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
import os

download_folder = './netflix-shows'

files = os.listdir(download_folder)
print("Files in the folder:")
for file in files:
    print(file)
"""

[cells.9a2f59d0-72dd-4c0e-a5a9-bb20749cc725]
cellName = ""
cellType = "sql"
hideCell = "True"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
SELECT * FROM 'netflix-shows/netflix_titles.csv'
LIMIT 5"""

[cells.0c18b330-294d-404f-8747-a0a413d34511]
cellName = ""
cellType = "markdown"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
## Part 1: Analysing The Movies/TV Shows Over the years
This includes the following:
* Analyzing the duration of the shows.
* Analyzing the count of movies over countries as per release date"""

[cells.8f985250-450d-4a1d-843c-909079d07e6b]
cellName = "Select Country "
cellType = "code"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
import pandas as pd 
import zero_true as zt

df = pd.read_csv('netflix-shows/netflix_titles.csv')
def process_countries(countries):
    processed_countries = []
    for country in countries:
        if isinstance(country, str):
            processed_countries.extend(country.split(','))
        else:
            processed_countries.append(country)
    return list(set(processed_countries))

countries = process_countries(df['country'].dropna().unique().tolist())
countries = list({country.strip() for country in countries if country.strip()})

countries.sort()
# print(len(countries))
country = zt.Autocomplete(id = 'country', items = countries, label = 'Select Country')"""

[cells.79b1ace0-db8a-4f61-8131-09dd98a07642]
cellName = ""
cellType = "code"
hideCell = "True"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
# print(country.value)
selected_country = country.value
# print(selected_country)"""

[cells.a2806a6d-2f02-4548-9804-7d589a43f847]
cellName = "Get list of Countries"
cellType = "sql"
hideCell = "True"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
SELECT *
FROM 'netflix-shows/netflix_titles.csv'
WHERE country LIKE '%'||{selected_country}||'%'
LIMIT 1;
"""

[cells.921bb5c3-0a46-497e-a627-237c9c1d5e52]
cellName = "Loading the CSV file to a Database"
cellType = "sql"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
--DROP TABLE IF EXISTS netflix_data;
CREATE TABLE IF NOT EXISTS netflix_data AS
SELECT * FROM 'netflix-shows/netflix_titles.csv';"""

[cells.e3e2b7fa-3989-4ee0-b71a-8e994edffae7]
cellName = "Check if data exists in table"
cellType = "sql"
hideCell = "True"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
SELECT * FROM netflix_data LIMIT 5;
"""

[cells.1841830d-5177-4300-a941-7a7e4c1f6d9e]
cellName = "Connecting to the Database"
cellType = "code"
hideCell = "True"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
import duckdb 

conn = duckdb.connect('zt_db.db')

# release_yr = [release_year[0] for release_year in conn.execute("SELECT DISTINCT release_year FROM netflix_data ORDER BY release_year").fetchall() if release_year[0] is not None]

# print(release_yr)"""

[cells.bf8455e6-bdd5-42d5-b131-d668457bc8ca]
cellName = "Select Range of Release Year for the Country (Range is provided based on the shows available for the selected country)"
cellType = "code"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
query = f'''
SELECT Distinct release_year FROM netflix_data
WHERE country LIKE '%{selected_country}%' ORDER BY release_year
'''
if not(selected_country and len(selected_country)>0):
    print("To get the range for release year, please select Country")
else:
    result = conn.execute(query).fetchall()
    
    import pandas as pd
    df = pd.DataFrame(result, columns=[desc[0] for desc in conn.description])
    # print(df)
    release_year = df['release_year'].dropna().tolist()
    
    # print(release_yr)
    release_year_slider = zt.RangeSlider(id='release_year',min=min(release_year),
                                                           max=max(release_year),
                                                           step=10, 
                                                          label='Select Range for Release year',
                                                            value = [min(release_year), max(release_year)]
                                                )"""

[cells.2eb18241-1b92-46a3-9657-2c81add25933]
cellName = "Select Type of Show"
cellType = "code"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
query = f'''
SELECT Distinct type FROM netflix_data;
'''

result = conn.execute(query).fetchall()

import pandas as pd
df = pd.DataFrame(result, columns=[desc[0] for desc in conn.description])
# print(df)
type_list = df['type'].dropna().tolist()

# print(release_yr)
show_type = zt.SelectBox(id='show_type', items = type_list, label = 'Select Type of Show')
selected_show_type = show_type.value"""

[cells.2a3c7f7c-37e2-47b9-9a20-62d564eae427]
cellName = ""
cellType = "sql"
hideCell = "True"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
SELECT * FROM netflix_data
WHERE country LIKE '%'||{selected_country}||'%'
AND release_year BETWEEN {release_year_slider.value[0]} AND {release_year_slider.value[1]} 
AND type In ({selected_show_type})"""

[cells.56e280d6-f9de-4cfb-9387-2152a4c9400a]
cellName = ""
cellType = "markdown"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
_Note_ : 
* For Movies, the duration is in Minutes. So, a line plot would be beneficial
* For TV Shows, the duration is in Seasons, hence a scatter plot would be beneficial as only one/two movies would have many seasons at a time. """

[cells.286e6bac-34eb-4826-a4a5-7b112242e3e1]
cellName = "Analysis of Duration of Shows"
cellType = "code"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
import plotly.express as px
from zero_true import state, PlotlyComponent, Button, Layout, Row
if not(selected_country and selected_show_type and len(selected_country)>0 and len(selected_show_type)>0):
    print("Please select Country, Range for release year and Show Type")
else:
    query = f'''
    SELECT release_year, duration FROM netflix_data
    WHERE country LIKE '%{selected_country}%'
    AND release_year BETWEEN {release_year_slider.value[0]} AND {release_year_slider.value[1]}
    AND type In ('{selected_show_type}')
    ORDER BY release_year;
    '''

    result = conn.execute(query).fetchall()
    
    import pandas as pd
    df = pd.DataFrame(result, columns=[desc[0] for desc in conn.description])
    # print(df)
    if selected_show_type == "Movie":
        df['duration_min'] = df['duration'].str.extract('(\d+)').fillna(0).astype(int)
        df = df[df['duration_min'] != 0]
        # Calculate the average duration by release year
        df_grouped = df.groupby('release_year')['duration_min'].mean().reset_index()
        
        # Create the line plot
        fig = px.line(df_grouped, x='release_year', y='duration_min',
                      labels={'release_year': 'Release Year', 'duration_min': 'Average Duration (min)'},
                      title='Average Duration of Movies by Release Year',
                      markers=True
                     )
        
        # Show the plot
        PlotlyComponent.from_figure(id='plot_duration_releaseyr', figure=fig)
    else: # it is a TV show
        df['seasons'] = df['duration'].str.extract('(\d+)').fillna(0).astype(int)
        df = df[df['seasons'] != 0]
        # Grouping and counting
        df_grouped = df.groupby(['release_year', 'seasons']).size().reset_index(name='count')
    
        # Create the area plot
        fig = px.scatter(df_grouped, x='release_year', y='count', color='seasons',
                      labels={'release_year': 'Release Year', 'count': 'Number of Shows'},
                      title='Number of Seasons per Release Year')
        
        # Show the plot
        PlotlyComponent.from_figure(id='plot_seasons_releaseyr', figure=fig)"""

[cells.9d9b3ec2-21f1-4bae-b522-39d738f3ed97]
cellName = "code"
cellType = "code"
hideCell = "True"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
if not(selected_country and selected_show_type and len(selected_country)>0 and len(selected_show_type)>0):
    print("Please select Country, Range for release year and Show Type")
else:
    query = f'''
    SELECT * FROM netflix_data
    WHERE country LIKE '%{selected_country}%'
    AND release_year BETWEEN {release_year_slider.value[0]} AND {release_year_slider.value[1]}
    AND type In ('{selected_show_type}')
    '''
    
    result = conn.execute(query).fetchall()
    
    import pandas as pd
    df = pd.DataFrame(result, columns=[desc[0] for desc in conn.description])
    print(df)
    print(conn.description)"""

[cells.ab086bdf-e0f3-4c46-8077-226d46235e47]
cellName = ""
cellType = "markdown"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
* Based on the filters, the plot will be generated for the Count of shows Based on Rating, Release year for the selected Country and range of Release year.
* Users can add the plots for comparison. Only 2 search results are allowed to be compared.
* In case of adding a new third search result for comparison, the oldest result gets deleted."""

[cells.4a4f7deb-49f1-4831-bc94-b582ab6f09e3]
cellName = "Analysis and Comparison of Shows in Countries By Release Year "
cellType = "code"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
import plotly.express as px
from zero_true import state, PlotlyComponent, Button, Layout, Row
if not(selected_country and selected_show_type and len(selected_country)>0 and len(selected_show_type)>0):
    print("Please select Country, Range for release year and Show Type")
else:
    # Grouping and creating the plot
    df_grouped = df.groupby(['release_year', 'rating']).size().reset_index(name='count')
    figure1 = px.bar(df_grouped, x='release_year', y='count', color='rating', 
                 labels={'release_year': 'Release Year', 'count': 'Number of Shows'},
                 title=f'Number of {selected_show_type}s for {selected_country} by Release Year ({release_year_slider.value[0]} - {release_year_slider.value[1]}) and Rating')
    
    # Initializing the state
    state = state()
    if "list" not in state:
        state["list"] = []
    
    # Checking if the current figure is already in the state list
    fig_exists = any(item.layout.title.text == figure1.layout.title.text for item in state["list"])
    clear_btn = Button(id='clear_btn', text='Clear Comparison')
    show_btn = Button(id='show_btn', text='Compare last 2 Elements Added for comparison')
    update_btn = Button(id='update_btn', text ="Add to Compare")
    
    def update_buttons(fig_exists):
        global layout, add_btn, rm_btn, clear_btn, show_btn
        # print("In update_buttons",fig_exists)
        if fig_exists:
            update_btn.text = "Remove from Compare"
            update_btn.variable_name = "rm_btn"
        else:
            update_btn.text = "Add to Compare"
            update_btn.variable_name = "add_btn"
        layout = Layout(rows=[Row(components=[update_btn.id, clear_btn.id, show_btn.id])])
    update_buttons(fig_exists)
    if fig_exists and update_btn.value and update_btn.variable_name == "rm_btn":
        # Remove the figure from the state list if it exists
        state["list"] = [item for item in state["list"] if item.layout.title.text != figure1.layout.title.text]
        fig_exists = False
        # print("Calling from rm_btn")
        update_buttons(fig_exists)  # Refresh buttons
    elif not fig_exists and update_btn.value and update_btn.variable_name == "add_btn":
        # Add the figure to the state list if it's not already present
        if len(state["list"]) >= 2:
            state["list"].pop(0)
        fig_exists = any(item.layout.title.text == figure1.layout.title.text for item in state["list"])
        if not fig_exists:
            state["list"].append(figure1)
        fig_exists = True
        # print("Calling from add_btn")
        update_buttons(fig_exists)  # Refresh buttons
    
    # Clear all items in the comparison list
    if clear_btn.value:
        state["list"] = []
        fig_exists = False
        # print("Calling from clear_btn")
        update_buttons(fig_exists)
    
    # Show the comparison if there are items in the list
    if show_btn.value:
        if len(state["list"]) > 0:
            PlotlyComponent.from_figure(id='Comparison 1', figure=state["list"][0])
        if len(state["list"]) > 1:
            PlotlyComponent.from_figure(id='Comparison 2', figure=state["list"][1])
    else:
        PlotlyComponent.from_figure(id='plotly', figure=figure1)
    
    # # Print the state for debugging purposes
    # print('Stateful List len', len(state["list"]))
    if len(state["list"]) > 0:
        print("Items for Comparison (Only 2 Allowed)")
        for item in state["list"]:
            print(item.layout.title.text)

"""

[cells.ee892c76-d148-4338-870f-fa47da7184f8]
cellName = ""
cellType = "sql"
hideCell = "True"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
SELECT * FROM netflix_data where country like '%United States%';"""

[cells.1dc7d61a-22e0-4d90-a9be-9443e3f0b70c]
cellName = ""
cellType = "markdown"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
## Part 2: Movie Actor Analysis
* Analysing the genres of the Actors in the movie:
  - Select the Country with Show Type Movie
  - Select the Actor/Actress who is casted in the movies of the selected Country
  - Display the total movies and the Genre Distribution of the movies where the actor has played a role."""

[cells.cdb4d79e-fe63-4215-91a0-3451792ba9e6]
cellName = ""
cellType = "sql"
hideCell = "True"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
-- Select count(*) from netflix_data;
-- Select Count(*) from netflix_data where director is NOT NULL;
Select * from netflix_data where "cast" is NOT NULL and type =='Movie';
"""

[cells.f83d79d6-61e7-4815-a0f1-293c0406b341]
cellName = "List All Countries with Movies"
cellType = "code"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
distinct_countries_query = '''
WITH split_countries AS (
    SELECT DISTINCT TRIM(UNNEST(REGEXP_SPLIT_TO_ARRAY(country, ','))) AS country, type
    FROM netflix_data
)
SELECT DISTINCT country
FROM split_countries
WHERE country IS NOT NULL AND country <> ''
AND type == 'Movie'
ORDER BY country;
'''

# Execute the query and fetch the distinct countries
distinct_countries = conn.execute(distinct_countries_query).fetchall()

# Convert the result to a list
country_list = [row[0] for row in distinct_countries]
# print(len(country_list))
country_for_movie = zt.Autocomplete(id = 'country_for_movie', items = country_list, label = 'Select Country')"""

[cells.7ccac3df-3ac7-4762-b68d-6fc104de3708]
cellName = "List all Actors Who Have been Casted in the Movie in the selected Country"
cellType = "code"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
selected_country_for_movie = country_for_movie.value
distinct_actors_query = f'''
    WITH split_actors AS (
        SELECT TRIM(UNNEST(REGEXP_SPLIT_TO_ARRAY("cast", ','))) AS actor
        FROM netflix_data 
        WHERE type =='Movie'
    )
    SELECT DISTINCT actor
    FROM split_actors
    WHERE actor IS NOT NULL AND actor <> ''
    ORDER BY actor;
    '''
if selected_country_for_movie and len(selected_country_for_movie)>0:
    distinct_actors_query = f'''
    WITH split_actors AS (
        SELECT TRIM(UNNEST(REGEXP_SPLIT_TO_ARRAY("cast", ','))) AS actor
        FROM netflix_data 
        WHERE country LIKE '%{selected_country_for_movie}%' 
        AND type =='Movie'
    )
    SELECT DISTINCT actor
    FROM split_actors
    WHERE actor IS NOT NULL AND actor <> ''
    ORDER BY actor;
    '''

# Execute the query and fetch the distinct actors
distinct_actors = conn.execute(distinct_actors_query).fetchall()

# Convert the result to a list
actor_list = [row[0] for row in distinct_actors]

# print("Distinct Actors:", actor_list)
actor_for_movie = zt.Autocomplete(id = 'actor_for_movie', items = actor_list, label = 'Select Actor/Actress')"""

[cells.5c90d9ff-fd59-4a4b-aa6b-7d6bbecff6bb]
cellName = "Analysis of Movie Genres Featuring Selected Actor"
cellType = "code"
hideCell = "False"
hideCode = "False"
expandCode = "False"
showTable = "False"
nonReactive = "False"
code = """
selected_actor_for_movie = actor_for_movie.value

if not(selected_actor_for_movie and len(selected_actor_for_movie)):
    print("Please select an Actor/Actress")
else:
    distinct_genre_query = f'''
    WITH split_genre AS (
        SELECT TRIM(UNNEST(REGEXP_SPLIT_TO_ARRAY(listed_in, ','))) AS listed_in, release_year
        FROM netflix_data 
        WHERE "cast" LIKE '%{selected_actor_for_movie}%'
        AND type =='Movie'
    )
    SELECT listed_in, count(*) as listed_count
    FROM split_genre
    WHERE listed_in IS NOT NULL AND listed_in <> ''
    Group by listed_in
    ORDER BY listed_in;
    '''
    actor_movie_count_query= f'''
    SELECT COUNT(*) AS movie_count
    FROM netflix_data 
    WHERE "cast" LIKE '%{selected_actor_for_movie}%'
    AND type =='Movie'
    '''
    if selected_country_for_movie and len(selected_country_for_movie)>0:
        distinct_genre_query = f'''
        WITH split_genre AS (
            SELECT TRIM(UNNEST(REGEXP_SPLIT_TO_ARRAY(listed_in, ','))) AS listed_in, release_year
            FROM netflix_data 
            WHERE country LIKE '%{selected_country_for_movie}%' 
            AND "cast" LIKE '%{selected_actor_for_movie}%'
            AND type =='Movie'
        )
        SELECT listed_in, count(*) as listed_count
        FROM split_genre
        WHERE listed_in IS NOT NULL AND listed_in <> ''
        Group by listed_in
        ORDER BY listed_in;
        '''
        actor_movie_count_query= f'''
        SELECT COUNT(*) AS movie_count
        FROM netflix_data 
        WHERE country LIKE '%{selected_country_for_movie}%' 
        AND "cast" LIKE '%{selected_actor_for_movie}%'
        AND type =='Movie'
        '''
    
    # Execute the query and fetch the distinct actors
    distinct_genre = conn.execute(distinct_genre_query).fetchall()
    # print(distinct_genre)
    actor_movie_count = conn.execute(actor_movie_count_query).fetchall()
    # print(actor_movie_count[0][0])
    
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
    
    
    # Unpacking the data
    genres, counts = zip(*distinct_genre)
    
    # Create a subplot figure with 2 rows and 1 column
    pie_figure = make_subplots(
        rows=2, cols=1,
        row_heights=[0.2, 0.8],
        vertical_spacing=0.1,
        specs=[[{"type": "indicator"}], [{"type": "pie"}]]
    )
    
    # Add the number plot for total movies
    pie_figure.add_trace(go.Indicator(
        mode="number",
        value=actor_movie_count[0][0],
        title={"text": "Total Movies"},
        domain={'x': [0, 1], 'y': [0, 1]}
    ), row=1, col=1)
    
    # Add the pie chart for genre distribution
    pie_figure.add_trace(go.Pie(
        labels=genres,
        values=counts,
        name=''
    ), row=2, col=1)
    
    title=f'Movie Participation in Different Genre'
    if selected_actor_for_movie and len(selected_actor_for_movie)>0:
        title+= f' for actor/actress {selected_actor_for_movie}'
    if selected_country_for_movie and len(selected_country_for_movie)>0:
        title+= f' in {selected_country_for_movie}'
    
    
    # Customize the layout
    pie_figure.update_layout(
        title= title
    )

    PlotlyComponent.from_figure(id='actor_genre_distribution', figure=pie_figure)
"""

